"""
è¾“å‡ºå±‚ï¼ˆOutput Formatterï¼‰ï¼š
æ ¹æ® OPTIMIZATION_NOTES.md çš„äº”å±‚æ¶æ„è®¾è®¡

èŒè´£ï¼š
- å°†æœ€ç»ˆç»“æœè¾“å‡ºä¸ºä¸­æ–‡æŠ¥å‘Š
- åŒ…å«ï¼šå¸‚åœºæ¦‚ç‡ã€AI å…±è¯†æ¦‚ç‡ã€AI è§‚ç‚¹æ€»ç»“ï¼ˆä¸­æ–‡ï¼‰
- æ”¯æŒå•é€‰é¡¹å’Œå¤šé€‰é¡¹ä¸¤ç§æ ¼å¼
- è‡ªåŠ¨åŒºåˆ†å€™é€‰äººå‹äº‹ä»¶å’Œæ¡ä»¶å‹äº‹ä»¶ï¼Œä½¿ç”¨ä¸åŒæ¨¡æ¿

è¾“å…¥ï¼šäº‹ä»¶æ•°æ® + èåˆç»“æœ
è¾“å‡ºï¼šæ ¼å¼åŒ–çš„ä¸­æ–‡ Markdown å­—ç¬¦ä¸²ï¼ˆTelegram æ¶ˆæ¯ï¼‰
"""
import re
from typing import Dict, List, Optional


class OutputFormatter:
    """
    Formats prediction results for Telegram Markdown output.
    
    æ ¼å¼åŒ–é¢„æµ‹ç»“æœä¸ºä¸­æ–‡æŠ¥å‘Šï¼š
    - å•é€‰é¡¹ï¼šæ˜¾ç¤ºèåˆé¢„æµ‹ã€å¸‚åœºä»·æ ¼ã€AIæ‘˜è¦ç­‰
    - å¤šé€‰é¡¹ï¼šæ˜¾ç¤ºæ¯ä¸ªé€‰é¡¹çš„é¢„æµ‹æ’åå’Œè¯¦ç»†ä¿¡æ¯
    - æ‰€æœ‰è¾“å‡ºå‡ä¸ºä¸­æ–‡
    - è‡ªåŠ¨åŒºåˆ†å€™é€‰äººå‹å’Œæ¡ä»¶å‹äº‹ä»¶
    """
    
    def __init__(self):
        pass
    
    @staticmethod
    def escape_markdown(text: str, preserve_asterisk: bool = False) -> str:
        """
        Escape special characters for Telegram Markdown.
        
        Telegram Markdown special characters: * _ [ ] ( ) ` ~
        
        Args:
            text: Text to escape
            preserve_asterisk: If True, don't escape * (useful when text will be inside *bold* tags)
        """
        if not text:
            return ""
        # Characters that need to be escaped in Telegram Markdown
        escape_chars = ['_', '[', ']', '(', ')', '`', '~']
        if not preserve_asterisk:
            escape_chars.append('*')
        
        escaped = str(text)
        for char in escape_chars:
            escaped = escaped.replace(char, f'\\{char}')
        return escaped
    
    @staticmethod
    def safe_markdown_text(text: str, max_length: int = None) -> str:
        """
        Safely prepare text for Markdown, escaping special characters.
        Also truncate if needed.
        """
        if not text:
            return ""
        
        # First escape special characters
        safe_text = OutputFormatter.escape_markdown(str(text))
        
        # Truncate if needed
        if max_length and len(safe_text) > max_length:
            safe_text = safe_text[:max_length - 3] + "..."
        
        return safe_text
    
    def classify_event_type(self, outcomes: List[Dict]) -> str:
        """
        åˆ†ç±»äº‹ä»¶ç±»å‹ï¼šå€™é€‰äººå‹ vs æ¡ä»¶å‹
        
        Args:
            outcomes: é€‰é¡¹åˆ—è¡¨ï¼Œæ¯ä¸ªåŒ…å« name å­—æ®µ
        
        Returns:
            "candidate" - å€™é€‰äººå‹äº‹ä»¶ï¼ˆäººåã€å›¢é˜Ÿåç­‰ï¼‰
            "conditional" - æ¡ä»¶å‹äº‹ä»¶ï¼ˆæ•°å€¼åŒºé—´ã€æ—¥æœŸç­‰ï¼‰
        """
        if not outcomes or len(outcomes) == 0:
            return "candidate"  # é»˜è®¤
        
        candidate_count = 0
        conditional_count = 0
        
        # æ¡ä»¶å‹ç‰¹å¾å…³é”®è¯
        conditional_keywords = [
            '%', '<', '>', 'below', 'above', 'between', 'range',
            'before', 'after', 'by', 'in', 'on',
            '$', 'â‚¬', 'Â¥', 'million', 'billion', 'trillion',
            'january', 'february', 'march', 'april', 'may', 'june',
            'july', 'august', 'september', 'october', 'november', 'december',
            '2024', '2025', '2026', '2027', '2028', '2029', '2030',
            'Q1', 'Q2', 'Q3', 'Q4', 'H1', 'H2',
            '-', 'â€“', 'â€”',  # åŒºé—´ç¬¦å·
            'less than', 'more than', 'at least', 'at most',
            'never', 'no', 'yes'  # ç®€å•é€‰é¡¹ä¹Ÿè§†ä¸ºæ¡ä»¶å‹
        ]
        
        for outcome in outcomes:
            name = outcome.get('name', '').strip()
            if not name:
                continue
            
            name_lower = name.lower()
            
            # æ£€æŸ¥æ¡ä»¶å‹ç‰¹å¾
            has_conditional = any(keyword in name_lower for keyword in conditional_keywords)
            
            # æ£€æŸ¥æ˜¯å¦åŒ…å«æ•°å­—
            has_number = bool(re.search(r'\d', name))
            
            # æ£€æŸ¥äººåç‰¹å¾
            # 1. åŒ…å«ç©ºæ ¼ï¼ˆå¦‚ "John Smith"ï¼‰
            # 2. é¦–å­—æ¯å¤§å†™ï¼ˆå¦‚ "Trump"ï¼‰
            # 3. ä¸åŒ…å«ç‰¹æ®Šç¬¦å·
            has_space = ' ' in name and len(name.split()) <= 4  # äººåé€šå¸¸ä¸è¶…è¿‡4ä¸ªè¯
            is_capitalized = name[0].isupper() if name else False
            has_no_special = not bool(re.search(r'[%<>$â‚¬Â¥\-â€“â€”\d]', name))
            
            # åˆ¤æ–­é€»è¾‘
            if has_conditional or has_number:
                conditional_count += 1
            elif has_space and is_capitalized and has_no_special:
                candidate_count += 1
            elif is_capitalized and has_no_special and len(name.split()) <= 2:
                # å•ä¸ªå¤§å†™è¯ï¼ˆå¦‚ "Trump", "Biden"ï¼‰
                candidate_count += 1
            else:
                # é»˜è®¤å½’ä¸ºæ¡ä»¶å‹
                conditional_count += 1
        
        print(f"ğŸ“Š äº‹ä»¶ç±»å‹åˆ¤æ–­: å€™é€‰äºº={candidate_count}, æ¡ä»¶å‹={conditional_count}")
        
        # åˆ¤æ–­æ•´ä½“ç±»å‹ï¼ˆå¤šæ•°åŸåˆ™ï¼‰
        if candidate_count > conditional_count:
            return "candidate"
        else:
            return "conditional"
    
    def format_conditional_prediction(
        self,
        event_data: Dict,
        outcomes: List[Dict],
        normalization_info: Dict = None,
        fusion_result: Optional[Dict] = None
    ) -> str:
        """
        æ ¼å¼åŒ–æ¡ä»¶å‹äº‹ä»¶é¢„æµ‹è¾“å‡ºï¼ˆæ•°å€¼åŒºé—´ã€æ—¥æœŸç­‰ï¼‰
        é‡‡ç”¨è¶‹åŠ¿å‹æ¨¡æ¿ï¼Œä¸ä½¿ç”¨"åæ¬¡"æˆ–"å€™é€‰äºº"æªè¾
        """
        question = event_data.get("question", "æœªçŸ¥äº‹ä»¶")
        question_escaped = self.safe_markdown_text(question)
        
        # æ ‡é¢˜
        output = f"ğŸ“Š *æ¡ä»¶äº‹ä»¶é¢„æµ‹ï¼š* {question_escaped}\n\n"
        
        # ã€å½’ä¸€åŒ–æ£€æŸ¥ä¿¡æ¯ã€‘
        if normalization_info:
            total_after = normalization_info.get("total_after")
            error = normalization_info.get("error", 0)
            is_normalized = normalization_info.get("normalized", True)  # é»˜è®¤ä¸º True ä¿æŒå…¼å®¹
            event_type = normalization_info.get("event_type", "unknown")
            
            # ã€ä¿®å¤ã€‘æ¡ä»¶äº‹ä»¶ï¼šè·³è¿‡å½’ä¸€åŒ–æ£€æŸ¥è¾“å‡ºï¼Œç›´æ¥æ˜¾ç¤ºæç¤ºä¿¡æ¯
            if event_type == "conditional":
                output += f"â„¹ï¸ *æ¡ä»¶äº‹ä»¶ä¸ºç‹¬ç«‹å¸‚åœºï¼ˆæ¦‚ç‡æœªå½’ä¸€åŒ–ï¼‰*\n\n"
            else:
                # äº’æ–¥äº‹ä»¶ï¼šæ˜¾ç¤ºå½’ä¸€åŒ–æ£€æŸ¥
                # ã€Bugä¿®å¤ã€‘å¦‚æœ total_after ä¸º None æˆ– 0ï¼Œå°è¯•ä» outcomes è®¡ç®—å®é™…æ€»å’Œ
                if total_after is None or total_after == 0:
                    # è®¡ç®—æ‰€æœ‰æœ‰æ•ˆé€‰é¡¹çš„ model_only_prob æ€»å’Œ
                    ai_sum = sum(
                        outcome.get('model_only_prob') or 0
                        for outcome in outcomes
                        if outcome.get('model_only_prob') is not None
                    )
                    if ai_sum > 0:
                        total_after = ai_sum
                        # ã€é˜²å¾¡ã€‘ç¡®ä¿ total_after ä¸ä¸º None
                        total_after = total_after or 0.0
                        if total_after is None:
                            print("âš ï¸ total_after is None, using default 0.0")
                            total_after = 0.0
                        print(f"[DEBUG] normalization_info total_after ä¸º 0ï¼Œä» outcomes è®¡ç®—å¾—åˆ°: {(total_after or 0.0):.2f}%")
                    else:
                        print(f"[WARNING] normalization_info total_after ä¸º 0ï¼Œä¸”æ— æ³•ä» outcomes è®¡ç®—")
                
                if total_after is not None:
                    # ã€é˜²å¾¡ã€‘ç¡®ä¿ total_after å’Œ error ä¸ä¸º None
                    total_after = total_after or 0.0
                    error = error or 0.0
                    if total_after is None:
                        print("âš ï¸ total_after is None in format, using default 0.0")
                        total_after = 0.0
                    if error is None:
                        print("âš ï¸ error is None, using default 0.0")
                        error = 0.0
                    output += f"ğŸ“Š *å½’ä¸€åŒ–æ£€æŸ¥ï¼š* Î£AIé¢„æµ‹ = {(total_after or 0.0):.2f}%\n"
                    if error > 0.01:
                        output += f"âš ï¸ å½’ä¸€åŒ–è¯¯å·®: {(error or 0.0):.2f}%\n"
                    output += "\n"
        
        # æ’åºï¼ˆæŒ‰AIé¢„æµ‹ä»é«˜åˆ°ä½ï¼‰
        sorted_outcomes = sorted(outcomes, key=lambda x: x.get("model_only_prob") or x.get("prediction", 0), reverse=True)
        
        # å„æ¡ä»¶é€‰é¡¹çš„AIé¢„æµ‹å’Œå¸‚åœºä»·æ ¼
        output += "ğŸ“ˆ *å„æ¡ä»¶é¢„æµ‹å¯¹æ¯”*\n\n"
        
        # è®¡ç®—å®é™…AIé¢„æµ‹æ€»å’Œï¼ˆç”¨äºéªŒè¯ï¼‰
        # ã€Bugä¿®å¤ã€‘åªè®¡ç®—æœ‰æ•ˆçš„ model_only_probï¼Œä¸ä½¿ç”¨ prediction ä½œä¸º fallback
        ai_sum = 0.0
        for outcome in sorted_outcomes:
            ai_prob = outcome.get('model_only_prob')  # åªä½¿ç”¨ model_only_probï¼Œä¸ä½¿ç”¨ prediction
            if ai_prob is not None:
                ai_sum += ai_prob
        
        for outcome in sorted_outcomes:
            name = outcome.get('name', 'æœªçŸ¥é€‰é¡¹')
            # ã€Bugä¿®å¤ã€‘ä¼˜å…ˆä½¿ç”¨å½’ä¸€åŒ–åçš„ model_only_probï¼ˆçº¯AIé¢„æµ‹ï¼‰
            # å¦‚æœ model_only_prob ä¸º Noneï¼Œè¯´æ˜è¯¥é€‰é¡¹è¢«è·³è¿‡äº†å½’ä¸€åŒ–ï¼Œä¸åº”è¯¥æ˜¾ç¤º AI é¢„æµ‹
            ai_prob = outcome.get('model_only_prob')
            market_prob = outcome.get('market_prob', 0)
            
            # è½¬ä¹‰Markdown
            name_escaped = self.safe_markdown_text(name)
            
            # æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆçš„AIé¢„æµ‹
            summary = outcome.get('summary', '')
            has_fallback = any(word in summary for word in [
                "æš‚æ— ", "æš‚ä¸å¯ç”¨", "æ²¡æœ‰å¯ç”¨çš„æ¨¡å‹", "ä½¿ç”¨å¸‚åœºæ¦‚ç‡", "ä½¿ç”¨å¸‚åœºä»·æ ¼"
            ])
            
            # ã€ä¿®å¤ã€‘ç¡®ä¿ ai_prob å’Œ market_prob ä¸ä¸º None ä¸”ä¸ºæ•°å€¼ç±»å‹
            if ai_prob is None:
                has_ai = False  # æ˜ç¡®æ ‡è®°ä¸ºæ²¡æœ‰ AI é¢„æµ‹
            else:
                try:
                    ai_prob_val = float(ai_prob)
                    market_prob_val = float(market_prob) if market_prob is not None else 0.0
                    has_ai = (ai_prob_val > 0 and ai_prob_val <= 100) and not has_fallback
                    
                    # ã€Bugä¿®å¤ã€‘éªŒè¯ ai_prob æ˜¯å¦å¼‚å¸¸ï¼ˆå¦‚ 100.0% å¯¹äºå•ä¸ªé€‰é¡¹æ¥è¯´é€šå¸¸ä¸åˆç†ï¼‰
                    if ai_prob_val == 100.0 and len(sorted_outcomes) > 1:
                        print(f"[WARNING] æ£€æµ‹åˆ°å¼‚å¸¸ AI é¢„æµ‹å€¼ï¼š{name} = {ai_prob_val}%ï¼Œå¯èƒ½å­˜åœ¨å½’ä¸€åŒ–é”™è¯¯")
                    
                    if has_ai:
                        output += f"â€¢ *{name_escaped}*\n"
                        output += f"  AIé¢„æµ‹: {ai_prob_val:.1f}% | å¸‚åœº: {market_prob_val:.1f}%"
                        
                        # è®¡ç®—åå·®ï¼ˆä½¿ç”¨å½’ä¸€åŒ–åçš„AIæ¦‚ç‡ï¼‰
                        diff = ai_prob_val - market_prob_val
                        diff = diff or 0.0
                        if diff is None:
                            print("âš™ï¸ [SAFE] ä¿®å¤ç©ºå€¼ä¿æŠ¤: diff")
                            diff = 0.0
                        if abs(diff) > 5:
                            if diff > 0:
                                output += f" \\(AIçœ‹å¥½ \\+{abs(diff or 0.0):.1f}%\\)"
                            else:
                                output += f" \\(å¸‚åœºçœ‹å¥½ \\+{abs(diff or 0.0):.1f}%\\)"
                        output += "\n\n"
                    else:
                        # åªæœ‰å¸‚åœºä»·æ ¼
                        output += f"â€¢ *{name_escaped}*\n"
                        output += f"  å¸‚åœº: {market_prob_val:.1f}%\n\n"
                except (TypeError, ValueError) as e:
                    print(f"âš ï¸ é€‰é¡¹ {name} çš„æ•°æ®æ ¼å¼é”™è¯¯ï¼ˆai_prob: {ai_prob}, market_prob: {market_prob}ï¼‰ï¼Œè·³è¿‡æ ¼å¼åŒ–: {e}")
                    try:
                        market_prob_val = float(market_prob) if market_prob is not None else 0.0
                        output += f"â€¢ *{name_escaped}*\n"
                        output += f"  å¸‚åœº: {market_prob_val:.1f}%\n\n"
                    except (TypeError, ValueError):
                        output += f"â€¢ *{name_escaped}*\n"
                        output += f"  å¸‚åœº: N/A\n\n"
            
            # å¦‚æœ ai_prob ä¸º Noneï¼Œç›´æ¥ä½¿ç”¨å¸‚åœºä»·æ ¼
            if ai_prob is None:
                try:
                    market_prob_val = float(market_prob) if market_prob is not None else 0.0
                    output += f"â€¢ *{name_escaped}*\n"
                    output += f"  å¸‚åœº: {market_prob_val:.1f}%\n\n"
                except (TypeError, ValueError):
                    output += f"â€¢ *{name_escaped}*\n"
                    output += f"  å¸‚åœº: N/A\n\n"
        
        # AIé€»è¾‘æ‘˜è¦ï¼ˆä½¿ç”¨ç¬¬ä¸€ä¸ªæœ‰æ•ˆæ‘˜è¦ï¼‰
        first_summary = None
        for outcome in sorted_outcomes:
            summary = outcome.get('summary', '')
            if summary and len(summary) > 30 and 'æš‚æ— ' not in summary:
                first_summary = summary
                break
        
        if first_summary:
            summary_escaped = self.safe_markdown_text(first_summary[:200])
            output += f"ğŸ§  *AIé€»è¾‘æ‘˜è¦*\n\n{summary_escaped}...\n\n"
        
        # å¸‚åœºåç¦»ä¿¡å·
        output += "ğŸš¨ *å¸‚åœºåç¦»ä¿¡å·*\n\n"
        
        significant_deviations = []
        for outcome in sorted_outcomes:
            name = outcome.get('name', 'æœªçŸ¥é€‰é¡¹')
            # ä½¿ç”¨å½’ä¸€åŒ–åçš„AIæ¦‚ç‡
            ai_prob = outcome.get('model_only_prob')
            if ai_prob is None:
                ai_prob = outcome.get('prediction', 0)
            market_prob = outcome.get('market_prob', 0)
            # ã€é˜²å¾¡ã€‘ç¡®ä¿æ‰€æœ‰å€¼ä¸ä¸º None
            ai_prob = ai_prob or 0.0
            market_prob = market_prob or 0.0
            if ai_prob is None:
                print("âš™ï¸ [SAFE] ä¿®å¤ç©ºå€¼ä¿æŠ¤: ai_prob (significant_deviations)")
                ai_prob = 0.0
            if market_prob is None:
                print("âš™ï¸ [SAFE] ä¿®å¤ç©ºå€¼ä¿æŠ¤: market_prob (significant_deviations)")
                market_prob = 0.0
            diff = (ai_prob or 0.0) - (market_prob or 0.0)
            diff = diff or 0.0
            if diff is None:
                print("âš™ï¸ [SAFE] ä¿®å¤ç©ºå€¼ä¿æŠ¤: diff (significant_deviations)")
                diff = 0.0
            
            if abs(diff) > 8:
                name_escaped = self.safe_markdown_text(name)
                if diff > 0:
                    significant_deviations.append(f"â€¢ \"{name_escaped}\" AIé«˜ä¼° \\(\\+{abs(diff or 0.0):.1f}%\\)")
                else:
                    significant_deviations.append(f"â€¢ \"{name_escaped}\" å¸‚åœºé«˜ä¼° \\(\\+{abs(diff or 0.0):.1f}%\\)")
        
        if significant_deviations:
            output += "\n".join(significant_deviations) + "\n\n"
        else:
            output += "â€¢ å„æ¡ä»¶é¢„æµ‹ä¸å¸‚åœºåŸºæœ¬ä¸€è‡´\n\n"
        
        # DeepSeek ç‹¬ç«‹åŒºå—ï¼ˆæ¡ä»¶å‹äº‹ä»¶ä¹Ÿæ˜¾ç¤ºï¼‰
        deepseek_section = ""
        deepseek_reasoning = None
        if fusion_result and fusion_result.get('deepseek_reasoning'):
            deepseek_reasoning = fusion_result.get('deepseek_reasoning')
        elif outcomes and len(outcomes) > 0:
            for outcome in outcomes:
                if 'deepseek_reasoning' in outcome and outcome['deepseek_reasoning']:
                    deepseek_reasoning = outcome['deepseek_reasoning']
                    break
        
        if deepseek_reasoning:
            deepseek_text = self.safe_markdown_text(deepseek_reasoning[:300])
            if len(deepseek_reasoning) > 300:
                for cutoff in range(297, max(200, len(deepseek_text) - 100), -1):
                    if deepseek_text[cutoff] in 'ã€‚.ï¼!ï¼Ÿ?\n':
                        deepseek_text = deepseek_text[:cutoff+1].strip()
                        break
                else:
                    deepseek_text += "..."
            deepseek_section = f"\nğŸ§  *æ¨¡å‹æ´å¯Ÿ \\(DeepSeek\\)*\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n{deepseek_text}\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        
        # é£é™©æç¤º
        output += "âš ï¸ *é£é™©æç¤º*\n"
        output += "æœ¬é¢„æµ‹åŸºäºAIè¯­è¨€æ¨¡å‹æ¨ç†ï¼Œä¸ä»£è¡¨çœŸå®æ¦‚ç‡ã€‚\n"
        output += "è¯·è°¨æ…å‚è€ƒï¼Œè‡ªè¡Œåˆ¤æ–­ã€‚\n\n"
        
        # DeepSeek åŒºå—
        if deepseek_section:
            output += deepseek_section
        
        # è§„åˆ™
        rules = event_data.get("rules", "")
        if rules and rules != "æŸ¥çœ‹åŸé“¾æ¥è·å–å®Œæ•´è§„åˆ™":
            rules_short = rules[:150]
            rules_escaped = self.safe_markdown_text(rules_short)
            output += f"ğŸ“œ *è§„åˆ™*\n{rules_escaped}...\n\n"
        
        # ã€å½’ä¸€åŒ–éªŒè¯ä¿¡æ¯ã€‘
        if normalization_info:
            total_after = normalization_info.get("total_after", 0)
            error = normalization_info.get("error", 0)
            is_normalized = normalization_info.get("normalized", True)
            
            # ã€Bugä¿®å¤ã€‘å¦‚æœ total_after ä¸º 0ï¼Œå°è¯•ä» outcomes è®¡ç®—å®é™…æ€»å’Œ
            if total_after == 0:
                ai_sum = sum(
                    outcome.get('model_only_prob') or 0
                    for outcome in sorted_outcomes
                    if outcome.get('model_only_prob') is not None
                )
                if ai_sum > 0:
                    total_after = ai_sum
                    # ã€é˜²å¾¡ã€‘ç¡®ä¿ total_after ä¸ä¸º None
                    total_after = total_after or 0.0
                    if total_after is None:
                        print("âš ï¸ total_after is None, using default 0.0")
                        total_after = 0.0
                    print(f"[DEBUG] å½’ä¸€åŒ–éªŒè¯ï¼šnormalization_info total_after ä¸º 0ï¼Œä» outcomes è®¡ç®—å¾—åˆ°: {(total_after or 0.0):.2f}%")
            
            # ã€ä¿®å¤ã€‘ç¡®ä¿ total_after å’Œ error ä¸ä¸º None
            if total_after is not None:
                try:
                    total_after_val = float(total_after)
                    error_val = float(error) if error is not None else 0.0
                    
                    if is_normalized:
                        if error_val <= 0.01:
                            output += f"âœ… *æ¦‚ç‡å½’ä¸€åŒ–å®Œæˆ* \\(æ€»å’Œ={total_after_val:.2f}%ï¼Œè¯¯å·®â‰¤{error_val:.4f}%\\)\n"
                        else:
                            output += f"âš ï¸ *å½’ä¸€åŒ–è­¦å‘Š* \\(æ€»å’Œ={total_after_val:.2f}%ï¼Œè¯¯å·®={error_val:.4f}%\\)\n"
                    else:
                        output += f"â„¹ï¸ *æ¡ä»¶äº‹ä»¶ç‹¬ç«‹å¸‚åœº* \\(æ€»å’Œ={total_after_val:.2f}%ï¼Œæœªå½’ä¸€åŒ–\\)\n"
                except (TypeError, ValueError):
                    print("âš ï¸ total_after æˆ– error æ•°æ®æ ¼å¼é”™è¯¯ï¼Œè·³è¿‡æ ¼å¼åŒ–")
                    output += f"â„¹ï¸ *æ¡ä»¶äº‹ä»¶ç‹¬ç«‹å¸‚åœº*ï¼ˆæœªå½’ä¸€åŒ–ï¼‰\n"
            else:
                output += f"â„¹ï¸ *æ¡ä»¶äº‹ä»¶ç‹¬ç«‹å¸‚åœº*ï¼ˆæœªå½’ä¸€åŒ–ï¼‰\n"
        else:
            # å¦‚æœæ²¡æœ‰å½’ä¸€åŒ–ä¿¡æ¯ï¼Œæ‰‹åŠ¨è®¡ç®—æ€»å’Œ
            ai_total = sum(
                outcome.get('model_only_prob') or outcome.get('prediction', 0) or 0
                for outcome in sorted_outcomes
                if outcome.get('model_only_prob') is not None or outcome.get('prediction') is not None
            )
            # ã€é˜²å¾¡ã€‘ç¡®ä¿ ai_total ä¸ä¸º None
            ai_total = ai_total or 0.0
            if ai_total is None:
                print("âš™ï¸ [SAFE] ä¿®å¤ç©ºå€¼ä¿æŠ¤: ai_total")
                ai_total = 0.0
            output += f"ğŸ“Š *AIé¢„æµ‹æ€»å’Œï¼š* {(ai_total or 0.0):.2f}%\n"
        
        return output
    
    def format_prediction(
        self,
        event_data: Dict,
        fusion_result: Dict
    ) -> str:
        """
        Format prediction result as Telegram message.
        
        Args:
            event_data: Dict with 'question', 'market_prob', 'rules', 'trend'
            fusion_result: Dict with 'final_prob', 'uncertainty', 'summary', 'disagreement'
        
        Returns:
            Formatted Markdown string
        """
        # Format trend arrow
        trend = event_data.get("trend", "â†’")
        if isinstance(trend, str):
            trend_symbol = trend
        else:
            trend_symbol = "â†‘" if trend > 0 else "â†“" if trend < 0 else "â†’"
        
        # Truncate rules if too long
        rules = event_data.get("rules", "")
        # If it's mock data, keep the warning visible
        if event_data.get("is_mock", False):
            short_rules = rules
        else:
            short_rules = rules[:150] + "..." if len(rules) > 150 else rules
        
        # Translate disagreement level
        disagreement_map = {
            "Low": "ä½",
            "Medium": "ä¸­",
            "High": "é«˜",
            "ä½": "ä½",
            "ä¸­": "ä¸­",
            "é«˜": "é«˜",
            "Unknown": "æœªçŸ¥"
        }
        disagreement_raw = fusion_result.get('disagreement', 'Unknown')
        disagreement_cn = disagreement_map.get(disagreement_raw, disagreement_raw if disagreement_raw in ["ä½", "ä¸­", "é«˜"] else "æœªçŸ¥")
        
        # Get pure model prediction (if available) or calculate from fusion result
        model_only_prob = fusion_result.get('model_only_prob')
        market_prob = event_data.get('market_prob', 0)
        model_count = fusion_result.get('model_count', 0)
        final_prob = fusion_result.get('final_prob', 0)
        
        # ã€é˜²å¾¡ã€‘ç¡®ä¿å…³é”®æ¦‚ç‡å€¼ä¸ä¸º None
        market_prob = market_prob or 0.0
        final_prob = final_prob or 0.0
        if market_prob is None:
            print("âš™ï¸ [SAFE] ä¿®å¤ç©ºå€¼ä¿æŠ¤: market_prob (format_prediction)")
            market_prob = 0.0
        if final_prob is None:
            print("âš™ï¸ [SAFE] ä¿®å¤ç©ºå€¼ä¿æŠ¤: final_prob (format_prediction)")
            final_prob = 0.0
        
        # Determine if we have valid AI prediction
        has_ai_prediction = False
        if model_only_prob is not None:
            # Direct value from fusion engine
            has_ai_prediction = True
        elif model_count > 0 and final_prob > 0:
            # Try to reverse calculate only if we have model responses
            from src.fusion_engine import FusionEngine
            try:
                model_only_prob = (final_prob - FusionEngine.MARKET_WEIGHT * market_prob) / FusionEngine.MODEL_WEIGHT
                # Validate the result makes sense
                if 0 <= model_only_prob <= 100:
                    has_ai_prediction = True
                else:
                    model_only_prob = None
            except (ZeroDivisionError, ValueError, TypeError):
                model_only_prob = None
        else:
            # No models responded, use final_prob as fallback (which is just market_prob)
            model_only_prob = None
        
        # Build output in Chinese
        # Escape special characters in user-provided content
        question_escaped = self.safe_markdown_text(event_data.get('question', 'æœªçŸ¥äº‹ä»¶'))
        summary_escaped = self.safe_markdown_text(fusion_result.get('summary', 'æš‚æ— æ‘˜è¦'))
        rules_escaped = self.safe_markdown_text(short_rules)
        
        # ã€ä¿®å¤ã€‘ç¡®ä¿ model_only_prob ä¸ä¸º None ä¸”ä¸ºæ•°å€¼ç±»å‹
        if has_ai_prediction and model_only_prob is not None:
            try:
                model_only_prob_val = float(model_only_prob)
                uncertainty_val = float(fusion_result.get('uncertainty', 0)) if fusion_result.get('uncertainty') is not None else 0.0
                ai_prediction_line = f"ğŸ¤– *çº¯AIé¢„æµ‹:* {model_only_prob_val:.1f}% Â± {uncertainty_val:.1f}%"
            except (TypeError, ValueError):
                print("âš ï¸ model_only_prob æ•°æ®æ ¼å¼é”™è¯¯ï¼Œè·³è¿‡æ ¼å¼åŒ–")
                ai_prediction_line = f"ğŸ¤– *çº¯AIé¢„æµ‹:* æš‚ä¸å¯ç”¨ (æ•°æ®æ ¼å¼é”™è¯¯)"
        else:
            ai_prediction_line = f"ğŸ¤– *çº¯AIé¢„æµ‹:* æš‚ä¸å¯ç”¨ (æ¨¡å‹æœªå“åº”)"
        
        # Check for DeepSeek reasoning - ç‹¬ç«‹åŒºå—æ˜¾ç¤º
        deepseek_reasoning = fusion_result.get('deepseek_reasoning')
        deepseek_section = ""
        if deepseek_reasoning:
            # ä¼˜åŒ–ï¼šæ˜¾ç¤ºæ›´å¤šå†…å®¹ï¼ˆ300å­—ç¬¦ï¼‰ï¼Œä½œä¸ºç‹¬ç«‹åŒºå—
            deepseek_text = self.safe_markdown_text(deepseek_reasoning[:300])
            # ç¡®ä¿å¥å­å®Œæ•´ï¼šå¦‚æœè¢«æˆªæ–­ï¼Œåœ¨å¥å­è¾¹ç•Œå¤„åœæ­¢
            if len(deepseek_reasoning) > 300:
                # æŸ¥æ‰¾æœ€è¿‘çš„å¥å­ç»“æŸç¬¦
                for cutoff in range(297, max(200, len(deepseek_text) - 100), -1):
                    if deepseek_text[cutoff] in 'ã€‚.ï¼!ï¼Ÿ?\n':
                        deepseek_text = deepseek_text[:cutoff+1].strip()
                        break
                else:
                    deepseek_text += "..."
            
            deepseek_section = f"\nğŸ§  *æ¨¡å‹æ´å¯Ÿ \\(DeepSeek\\)*\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n{deepseek_text}\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        
        # Model versions section
        model_versions = fusion_result.get('model_versions', {})
        versions_section = ""
        if model_versions:
            versions_lines = []
            for model_id, version_info in model_versions.items():
                display_name = version_info.get("display_name", model_id)
                last_updated = version_info.get("last_updated", "æœªçŸ¥")
                versions_lines.append(f"â€¢ {display_name} \\(æ›´æ–°: {last_updated}\\)")
            
            if versions_lines:
                versions_text = "\n".join(versions_lines)
                versions_section = f"\nğŸ§© *æ¨¡å‹ç‰ˆæœ¬æ‘˜è¦*\n{versions_text}\n\n"
        
        # Weight source section
        weight_source = fusion_result.get('weight_source', {})
        weight_source_section = ""
        if weight_source:
            source = weight_source.get("source", "æœªçŸ¥")
            updated_at = weight_source.get("updated_at", "æœªçŸ¥")
            file_name = weight_source.get("file", "æœªçŸ¥")
            weight_source_section = f"\nğŸ“Š *æ¨¡å‹æƒé‡æ¥æº:* {file_name} \\| æ›´æ–°æ—¶é—´: {updated_at}\n\n"
        
        # äº‹ä»¶åˆ†æä¿¡æ¯ï¼ˆå¸‚åœºè¶‹åŠ¿ã€ç±»åˆ«ã€èˆ†æƒ…ã€è§„åˆ™æ‘˜è¦ï¼‰
        analysis_section = ""
        full_analysis = event_data.get("full_analysis")
        if full_analysis:
            category_display = {
                "geopolitics": "åœ°ç¼˜æ”¿æ²»",
                "economy": "ç»æµæŒ‡æ ‡",
                "tech": "ç§‘æŠ€äº§å“",
                "social": "ç¤¾ä¼šäº‹ä»¶",
                "sports": "ä½“è‚²èµ›äº‹",
                "general": "é€šç”¨äº‹ä»¶"
            }
            category_cn = category_display.get(full_analysis.get("event_category", "general"), "é€šç”¨äº‹ä»¶")
            sentiment_map = {"positive": "æ­£é¢", "negative": "è´Ÿé¢", "neutral": "ä¸­æ€§", "unknown": "æœªçŸ¥"}
            sentiment_cn = sentiment_map.get(full_analysis.get("sentiment_trend", "unknown"), "æœªçŸ¥")
            
            # èˆ†æƒ…æ ·æœ¬é‡æç¤º
            sentiment_sample = full_analysis.get('sentiment_sample', 0)
            if sentiment_sample < 30:
                sample_hint = "ï¼ˆå¼±ä¿¡å·ï¼‰"
            elif sentiment_sample < 100:
                sample_hint = "ï¼ˆä¸­ä¿¡å·ï¼‰"
            else:
                sample_hint = "ï¼ˆå¼ºä¿¡å·ï¼‰"
            
            # ã€é˜²å¾¡ã€‘ç¡®ä¿ sentiment_score ä¸ä¸º None
            sentiment_score = full_analysis.get('sentiment_score') or 0.0
            if sentiment_score is None:
                print("âš ï¸ sentiment_score is None, using default 0.0")
                sentiment_score = 0.0
            
            analysis_lines = [
                f"ğŸ§­ *äº‹ä»¶ç±»åˆ«:* {category_cn}",
                f"ğŸ“ˆ *å¸‚åœºè¶‹åŠ¿:* {full_analysis.get('market_trend', 'æ•°æ®ä¸è¶³ï¼Œæ— æ³•è®¡ç®—')}",
                f"ğŸ“° *èˆ†æƒ…è¶‹åŠ¿:* {sentiment_cn} ({(sentiment_score or 0.0):+.2f})ï¼Œ"
                f"æ ·æœ¬ï¼š{sentiment_sample} ç¯‡{sample_hint}ï¼ˆæ¥æºï¼š{full_analysis.get('sentiment_source', 'æœªçŸ¥')}ï¼‰",
                f"ğŸ“œ *è§„åˆ™æ‘˜è¦:* {self.safe_markdown_text(full_analysis.get('rules_summary', 'æ— è§„åˆ™ä¿¡æ¯'))}"
            ]
            analysis_section = "\n".join(analysis_lines) + "\n\n"
        
        # è¯„ä¼°æ‘˜è¦ï¼ˆå¦‚æœæœ‰çœŸå®æ ‡ç­¾æˆ–å›æµ‹æ¨¡å¼ï¼‰
        evaluation_section = ""
        if event_data.get("evaluation_mode", False) and event_data.get("true_label") is not None:
            try:
                from metrics import compute_all_metrics
                
                true_label = event_data["true_label"]
                pred_prob = final_prob / 100.0  # è½¬æ¢ä¸º0-1èŒƒå›´
                
                # è®¡ç®—æŒ‡æ ‡
                eval_metrics = compute_all_metrics(
                    [true_label],
                    [pred_prob] if isinstance(true_label, (int, float)) else pred_prob
                )
                
                # ä¸åŸºçº¿æ¯”è¾ƒï¼ˆå¦‚æœæœ‰ï¼‰
                baseline_diff = None
                p_value = None
                if "baseline_metrics" in event_data:
                    baseline = event_data["baseline_metrics"]
                    # ã€é˜²å¾¡ã€‘ç¡®ä¿æ‰€æœ‰è¯„ä¼°æŒ‡æ ‡ä¸ä¸º None
                    brier_base = eval_metrics.get("brier") or 0.0
                    log_loss_base = eval_metrics.get("log_loss") or 0.0
                    ece_base = eval_metrics.get("ece") or 0.0
                    if brier_base is None:
                        print("âš™ï¸ [SAFE] ä¿®å¤ç©ºå€¼ä¿æŠ¤: brier_base")
                        brier_base = 0.0
                    if log_loss_base is None:
                        print("âš™ï¸ [SAFE] ä¿®å¤ç©ºå€¼ä¿æŠ¤: log_loss_base")
                        log_loss_base = 0.0
                    if ece_base is None:
                        print("âš™ï¸ [SAFE] ä¿®å¤ç©ºå€¼ä¿æŠ¤: ece_base")
                        ece_base = 0.0
                    baseline_brier = baseline.get("brier") or 0.0
                    baseline_log_loss = baseline.get("log_loss") or 0.0
                    baseline_ece = baseline.get("ece") or 0.0
                    baseline_diff = {
                        "brier": (brier_base or 0.0) - (baseline_brier or 0.0),
                        "log_loss": (log_loss_base or 0.0) - (baseline_log_loss or 0.0),
                        "ece": (ece_base or 0.0) - (baseline_ece or 0.0)
                    }
                    if "p_value" in event_data:
                        p_value = event_data["p_value"]
                
                # ã€é˜²å¾¡ã€‘ç¡®ä¿æ‰€æœ‰è¯„ä¼°æŒ‡æ ‡ä¸ä¸º None
                brier = eval_metrics.get('brier') or 0.0
                log_loss = eval_metrics.get('log_loss') or 0.0
                ece = eval_metrics.get('ece') or 0.0
                sharpness = eval_metrics.get('sharpness') or 0.0
                if brier is None:
                    print("âš™ï¸ [SAFE] ä¿®å¤ç©ºå€¼ä¿æŠ¤: brier")
                    brier = 0.0
                if log_loss is None:
                    print("âš™ï¸ [SAFE] ä¿®å¤ç©ºå€¼ä¿æŠ¤: log_loss")
                    log_loss = 0.0
                if ece is None:
                    print("âš™ï¸ [SAFE] ä¿®å¤ç©ºå€¼ä¿æŠ¤: ece")
                    ece = 0.0
                if sharpness is None:
                    print("âš™ï¸ [SAFE] ä¿®å¤ç©ºå€¼ä¿æŠ¤: sharpness")
                    sharpness = 0.0
                
                eval_lines = [
                    f"ğŸ“Š *è¯„ä¼°æ‘˜è¦*",
                    f"Brier: {(brier or 0.0):.4f}",
                    f"LogLoss: {(log_loss or 0.0):.4f}",
                    f"ECE: {(ece or 0.0):.4f}",
                    f"Sharpness: {(sharpness or 0.0):.4f}"
                ]
                
                if baseline_diff:
                    eval_lines.append("\n*ä¸åŸºçº¿å¯¹æ¯”:*")
                    for metric, diff in baseline_diff.items():
                        # ã€é˜²å¾¡ã€‘ç¡®ä¿ diff ä¸ä¸º None
                        diff = diff or 0.0
                        if diff is None:
                            print(f"âš™ï¸ [SAFE] ä¿®å¤ç©ºå€¼ä¿æŠ¤: baseline_diff[{metric}]")
                            diff = 0.0
                        sign = "+" if diff >= 0 else ""
                        eval_lines.append(f"{metric}: {sign}{(diff or 0.0):.4f}")
                
                if p_value is not None:
                    # ã€é˜²å¾¡ã€‘ç¡®ä¿ p_value ä¸ä¸º None
                    p_value = p_value or 0.0
                    if p_value is None:
                        print("âš™ï¸ [SAFE] ä¿®å¤ç©ºå€¼ä¿æŠ¤: p_value")
                        p_value = 0.0
                    significance = "***" if p_value < 0.001 else "**" if p_value < 0.01 else "*" if p_value < 0.05 else ""
                    eval_lines.append(f"\np-value: {(p_value or 0.0):.4f}{significance}")
                
                evaluation_section = "\n".join(eval_lines) + "\n\n"
            except ImportError:
                pass  # metricsæ¨¡å—æœªå®‰è£…æ—¶è·³è¿‡
            except Exception as e:
                print(f"âš ï¸ è®¡ç®—è¯„ä¼°æŒ‡æ ‡å¤±è´¥: {e}")
        
        # åä»ä¼—ç³»æ•°æ ‡æ³¨
        demarket_note = ""
        if fusion_result.get("demarket_applied"):
            demarket_note = f"\nğŸ’¡ {fusion_result.get('demarket_note', 'Applied de-marketization penalty.')}\n"
        
        output = f"""ğŸ“Š *äº‹ä»¶:* {question_escaped}

{analysis_section}{ai_prediction_line}
ğŸ“ˆ *å¸‚åœºä»·æ ¼:* {(market_prob or 0.0):.1f}%
ğŸ§  *èåˆé¢„æµ‹:* {(final_prob or 0.0):.1f}% (80% AI + 20% å¸‚åœº)
{demarket_note}{deepseek_section}{versions_section}{weight_source_section}{evaluation_section}ğŸ’¬ *æ‘˜è¦:* {summary_escaped}
âš–ï¸ *åˆ†æ­§ç¨‹åº¦:* {disagreement_cn}
ğŸ“œ *è§„åˆ™:* {rules_escaped}"""
        
        return output
    
    def format_multi_option_prediction(
        self,
        event_data: Dict,
        outcomes: List[Dict],
        normalization_info: Dict = None,
        fusion_result: Optional[Dict] = None
    ) -> str:
        """
        Format multi-option prediction result.
        è‡ªåŠ¨åŒºåˆ†å€™é€‰äººå‹å’Œæ¡ä»¶å‹äº‹ä»¶ï¼Œä½¿ç”¨ä¸åŒæ¨¡æ¿ã€‚
        
        Args:
            event_data: Dict with 'question', 'rules', etc.
            outcomes: List of dicts with 'name', 'prediction', 'market_prob', 'uncertainty', 'summary'
        
        Returns:
            Formatted Markdown string
        """
        # Handle empty outcomes
        if not outcomes:
            question_escaped = self.safe_markdown_text(event_data.get('question', 'æœªçŸ¥äº‹ä»¶'))
            output = f"""ğŸ“Š *äº‹ä»¶:* {question_escaped}

âš ï¸ *å¤šé€‰é¡¹é¢„æµ‹ç»“æœ:*

æœªèƒ½è·å–é€‰é¡¹æ•°æ®ã€‚è¯·ç¨åé‡è¯•ã€‚
"""
            rules = event_data.get("rules", "")
            if rules and not event_data.get("is_mock", False):
                short_rules = rules[:150] + "..." if len(rules) > 150 else rules
                rules_escaped = self.safe_markdown_text(short_rules)
                output += f"\nğŸ“œ *è§„åˆ™:* {rules_escaped}"
            return output
        
        # ã€å…³é”®æ”¹è¿›ã€‘åˆ†ç±»äº‹ä»¶ç±»å‹
        event_type = self.classify_event_type(outcomes)
        print(f"âœ… äº‹ä»¶ç±»å‹è¯†åˆ«ä¸º: {event_type}")
        
        # å¦‚æœæ˜¯æ¡ä»¶å‹äº‹ä»¶ï¼Œä½¿ç”¨æ¡ä»¶å‹æ¨¡æ¿
        if event_type == "conditional":
            return self.format_conditional_prediction(
                event_data, 
                outcomes, 
                normalization_info,
                fusion_result=fusion_result  # ä¼ é€’ fusion_result ä»¥æ˜¾ç¤º DeepSeek
            )
        
        # ===== å€™é€‰äººå‹äº‹ä»¶ï¼šä¿æŒåŸæœ‰æ ¼å¼ =====
        
        # Sort outcomes by normalized AI prediction (descending)
        # ä½¿ç”¨å½’ä¸€åŒ–åçš„ model_only_prob è¿›è¡Œæ’åº
        sorted_outcomes = sorted(
            outcomes,
            key=lambda x: x.get("model_only_prob") or x.get("prediction", 0),
            reverse=True
        )
        
        print(f"ğŸ“ æ ¼å¼åŒ– {len(sorted_outcomes)} ä¸ªé€‰é¡¹ (å€™é€‰äººå‹)")
        print(f"   åŸå§‹ outcomes é•¿åº¦: {len(outcomes)}")
        print(f"   å‰3ä¸ªoutcomes: {[o.get('name', 'N/A') for o in outcomes[:3]]}")
        
        if len(sorted_outcomes) == 0:
            print(f"âš ï¸ è­¦å‘Š: sorted_outcomes ä¸ºç©ºï¼åŸå§‹ outcomes é•¿åº¦: {len(outcomes)}")
            print(f"   outcomeså†…å®¹: {outcomes}")
            question_escaped = self.safe_markdown_text(event_data.get('question', 'æœªçŸ¥äº‹ä»¶'))
            return f"""ğŸ“Š *äº‹ä»¶:* {question_escaped}

âš ï¸ *å¤šé€‰é¡¹é¢„æµ‹ç»“æœ:*

æœªèƒ½è·å–é€‰é¡¹æ•°æ®ã€‚è¯·ç¨åé‡è¯•ã€‚"""
        
        # Build output - escape question
        question_escaped = self.safe_markdown_text(event_data.get('question', 'æœªçŸ¥äº‹ä»¶'))
        output = f"""ğŸ“Š *äº‹ä»¶:* {question_escaped}

"""
        
        # ã€å½’ä¸€åŒ–æ£€æŸ¥ä¿¡æ¯ã€‘
        if normalization_info:
            total_after = normalization_info.get("total_after")
            event_type = normalization_info.get("event_type", "unknown")
            
            # ã€ä¿®å¤ã€‘æ¡ä»¶äº‹ä»¶ï¼šè·³è¿‡å½’ä¸€åŒ–æ£€æŸ¥è¾“å‡ºï¼Œç›´æ¥æ˜¾ç¤ºæç¤ºä¿¡æ¯
            if event_type == "conditional":
                output += f"â„¹ï¸ *æ¡ä»¶äº‹ä»¶ä¸ºç‹¬ç«‹å¸‚åœºï¼ˆæ¦‚ç‡æœªå½’ä¸€åŒ–ï¼‰*\n\n"
            else:
                # äº’æ–¥äº‹ä»¶ï¼šæ˜¾ç¤ºå½’ä¸€åŒ–æ£€æŸ¥
                # ã€é˜²å¾¡ã€‘ç¡®ä¿ total_after ä¸ä¸º None
                total_after = total_after or 0.0
                if total_after is None:
                    print("âš™ï¸ [SAFE] ä¿®å¤ç©ºå€¼ä¿æŠ¤: total_after (format_multi_option)")
                    total_after = 0.0
                if total_after is not None and total_after > 0:
                    output += f"ğŸ“Š *å½’ä¸€åŒ–æ£€æŸ¥ï¼š* Î£AIé¢„æµ‹ = {(total_after or 0.0):.2f}%\n\n"
        
        output += """ğŸ¯ *å¤šé€‰é¡¹é¢„æµ‹ç»“æœ:*

"""
        
        # Add top 3-5 outcomes with details
        for i, outcome in enumerate(sorted_outcomes[:5], 1):
            # Escape option name to prevent Markdown parsing errors
            name = self.safe_markdown_text(outcome.get("name", "æœªçŸ¥é€‰é¡¹"))
            # ä¼˜å…ˆä½¿ç”¨å½’ä¸€åŒ–åçš„ model_only_probï¼ˆçº¯AIé¢„æµ‹ï¼‰è¿›è¡Œæ’åºå’Œæ˜¾ç¤º
            ai_pred = outcome.get("model_only_prob")
            if ai_pred is None:
                ai_pred = outcome.get("prediction", 0)
            pred = outcome.get("prediction", 0)  # èåˆåçš„æ¦‚ç‡ï¼ˆç”¨äºå…¶ä»–ç”¨é€”ï¼‰
            market = outcome.get("market_prob", 0)
            uncertainty = outcome.get("uncertainty", 10.0)
            
            # Calculate difference using normalized AI prediction (not fused prediction)
            # ä½¿ç”¨å½’ä¸€åŒ–åçš„AIé¢„æµ‹è®¡ç®—å·®å€¼
            ai_pred_for_diff = ai_pred if ai_pred is not None else pred
            # ã€é˜²å¾¡ã€‘ç¡®ä¿æ‰€æœ‰å€¼ä¸ä¸º None
            ai_pred_for_diff = ai_pred_for_diff or 0.0
            market = market or 0.0
            if ai_pred_for_diff is None:
                print("âš ï¸ ai_pred_for_diff is None, using default 0.0")
                ai_pred_for_diff = 0.0
            if market is None:
                print("âš ï¸ market is None, using default 0.0")
                market = 0.0
            diff = ai_pred_for_diff - market
            diff = diff or 0.0
            if diff is None:
                print("âš ï¸ diff is None, using default 0.0")
                diff = 0.0
            # Escape + sign in diff_str
            diff_str = f"{'+' if diff > 0 else ''}{(diff or 0.0):.1f}%"
            
            # Emoji indicator
            if i == 1:
                emoji = "ğŸ¥‡"
            elif i == 2:
                emoji = "ğŸ¥ˆ"
            elif i == 3:
                emoji = "ğŸ¥‰"
            else:
                emoji = "ğŸ“Œ"
            
            # Check if this is actually AI prediction or just market price
            summary = outcome.get("summary", "")
            
            # Debug: print summary for first outcome
            if i == 1:
                print(f"ğŸ” ç¬¬ä¸€ä¸ªé€‰é¡¹çš„ summary: {summary[:200]}")
                # ã€é˜²å¾¡ã€‘ç¡®ä¿ pred å’Œ market ä¸ä¸º None
                pred = pred or 0.0
                market = market or 0.0
                if pred is None:
                    print("âš™ï¸ [SAFE] ä¿®å¤ç©ºå€¼ä¿æŠ¤: pred")
                    pred = 0.0
                if market is None:
                    print("âš™ï¸ [SAFE] ä¿®å¤ç©ºå€¼ä¿æŠ¤: market")
                    market = 0.0
                diff_debug = (pred or 0.0) - (market or 0.0)
                print(f"ğŸ” prediction: {(pred or 0.0):.2f}%, market: {(market or 0.0):.2f}%, diff: {abs(diff_debug):.2f}%")
            
            # Determine if this is a real AI prediction
            # Threshold: if prediction and market differ by at least 0.5%, consider it AI prediction
            # (More lenient than before to catch edge cases where AI prediction is close to market)
            pred_diff = abs(pred - market)
            pred_exactly_matches = pred_diff < 0.1  # Exactly same (within 0.1%)
            
            # Check for fallback messages in summary
            has_fallback_message = any(word in summary for word in [
                "æš‚æ— ", "æš‚ä¸å¯ç”¨", "æ²¡æœ‰å¯ç”¨çš„æ¨¡å‹", "ä½¿ç”¨å¸‚åœºæ¦‚ç‡", 
                "æ˜¾ç¤ºå¸‚åœºä»·æ ¼", "æ²¡æœ‰å¯ç”¨çš„æ¨¡å‹å“åº”", "ä½¿ç”¨å¸‚åœº", "âš ï¸"
            ])
            
            # Has meaningful summary (not just fallback message)
            has_meaningful_summary = len(summary) > 30 and not has_fallback_message
            
            # It's a real AI prediction if:
            # 1. Has valid AI prediction (model_only_prob exists or can be derived)
            # 2. AND no fallback messages in summary
            # 3. AND summary has meaningful content
            # OR: if uncertainty is reasonable (> 0) and summary exists (even if diff is small)
            has_valid_ai = ai_pred is not None and ai_pred > 0
            is_ai_prediction = (
                has_valid_ai and              # Has valid AI prediction
                not pred_exactly_matches and  # Must differ from market (if using pred)
                has_meaningful_summary        # Has real content, not fallback
            ) or (
                has_valid_ai and
                uncertainty > 0.1 and         # Has uncertainty value
                has_meaningful_summary         # Has real content
            )
            
            # Escape parentheses in diff_str to prevent Markdown parsing errors
            # Note: diff_str format is like "+1.5%" or "-2.3%", which may contain special chars
            diff_str_escaped = diff_str.replace('(', '\\(').replace(')', '\\)')
            
            # Format the option line carefully
            # The format "*{i}. {name}*" can break if name contains * or other special chars
            # Solution: Don't put name inside bold tags, just the number
            # Or: Use a safer format that avoids Markdown parsing issues
            if is_ai_prediction:
                # æ˜¾ç¤ºå½’ä¸€åŒ–åçš„AIé¢„æµ‹ï¼ˆmodel_only_probï¼‰
                ai_display = ai_pred if ai_pred is not None else pred
                # ã€é˜²å¾¡ã€‘ç¡®ä¿æ‰€æœ‰å€¼ä¸ä¸º None
                ai_display = ai_display or 0.0
                uncertainty = uncertainty or 0.0
                market = market or 0.0
                if ai_display is None:
                    print(f"âš ï¸ ai_display is None for {name}, using default 0.0")
                    ai_display = 0.0
                if uncertainty is None:
                    print(f"âš ï¸ uncertainty is None for {name}, using default 0.0")
                    uncertainty = 0.0
                if market is None:
                    print(f"âš ï¸ market is None for {name}, using default 0.0")
                    market = 0.0
                output += f"""{emoji} *{i}.* {name}
   ğŸ¤– AIé¢„æµ‹: {(ai_display or 0.0):.1f}% Â± {(uncertainty or 0.0):.1f}%
   ğŸ“ˆ å¸‚åœºä»·æ ¼: {(market or 0.0):.1f}% ({diff_str_escaped})
   
"""
            else:
                # Just market price, no AI prediction available
                # ã€é˜²å¾¡ã€‘ç¡®ä¿ market ä¸ä¸º None
                market = market or 0.0
                if market is None:
                    print(f"âš ï¸ market is None for {name}, using default 0.0")
                    market = 0.0
                output += f"""{emoji} *{i}.* {name}
   ğŸ“ˆ å¸‚åœºä»·æ ¼: {(market or 0.0):.1f}%
   âš ï¸ AIé¢„æµ‹æš‚ä¸å¯ç”¨
   
"""
        
        # Show remaining outcomes if any
        if len(sorted_outcomes) > 5:
            remaining = sorted_outcomes[5:]
            output += f"\n_å…¶ä»–é€‰é¡¹ \\({len(remaining)} ä¸ª\\):_\n"
            for outcome in remaining:
                name_escaped = self.safe_markdown_text(outcome['name'])
                # ã€é˜²å¾¡ã€‘ç¡®ä¿ prediction å’Œ market_prob ä¸ä¸º None
                prediction = outcome.get('prediction') or 0.0
                market_prob = outcome.get('market_prob') or 0.0
                if prediction is None:
                    print(f"âš ï¸ prediction is None for {name_escaped}, using default 0.0")
                    prediction = 0.0
                if market_prob is None:
                    print(f"âš ï¸ market_prob is None for {name_escaped}, using default 0.0")
                    market_prob = 0.0
                output += f"  â€¢ {name_escaped}: {(prediction or 0.0):.1f}% \\(å¸‚åœº: {(market_prob or 0.0):.1f}%\\)\n"
        
        # Add rules if available
        rules = event_data.get("rules", "")
        if rules and not event_data.get("is_mock", False):
            short_rules = rules[:150] + "..." if len(rules) > 150 else rules
            rules_escaped = self.safe_markdown_text(short_rules)
            output += f"\nğŸ“œ *è§„åˆ™:* {rules_escaped}\n"
        
        # Model versions section (for multi-option events)
        # Collect model versions and weight source from all outcomes (they should all have the same versions)
        model_versions = None
        weight_source = None
        if outcomes and len(outcomes) > 0:
            # Try to get from first outcome (if stored during fusion)
            for outcome in outcomes:
                if 'model_versions' in outcome and outcome['model_versions']:
                    model_versions = outcome['model_versions']
                if 'weight_source' in outcome and outcome['weight_source']:
                    weight_source = outcome['weight_source']
                if model_versions and weight_source:
                    break
        
        versions_section = ""
        if model_versions:
            versions_lines = []
            for model_id, version_info in model_versions.items():
                display_name = version_info.get("display_name", model_id)
                last_updated = version_info.get("last_updated", "æœªçŸ¥")
                versions_lines.append(f"â€¢ {display_name} \\(æ›´æ–°: {last_updated}\\)")
            
            if versions_lines:
                versions_text = "\n".join(versions_lines)
                versions_section = f"\nğŸ§© *æ¨¡å‹ç‰ˆæœ¬æ‘˜è¦*\n{versions_text}\n"
        
        # Weight source section (for multi-option events)
        weight_source_section = ""
        if weight_source:
            source = weight_source.get("source", "æœªçŸ¥")
            updated_at = weight_source.get("updated_at", "æœªçŸ¥")
            file_name = weight_source.get("file", "æœªçŸ¥")
            weight_source_section = f"\nğŸ“Š *æ¨¡å‹æƒé‡æ¥æº:* {file_name} \\| æ›´æ–°æ—¶é—´: {updated_at}\n"
        
        # ã€å½’ä¸€åŒ–éªŒè¯ä¿¡æ¯ã€‘
        if normalization_info:
            total_after = normalization_info.get("total_after", 0)
            error = normalization_info.get("error", 0)
            is_normalized = normalization_info.get("normalized", True)
            
            # ã€Bugä¿®å¤ã€‘å¦‚æœ total_after ä¸º 0ï¼Œå°è¯•ä» outcomes è®¡ç®—å®é™…æ€»å’Œ
            if total_after == 0:
                ai_sum = sum(
                    outcome.get('model_only_prob') or 0
                    for outcome in sorted_outcomes
                    if outcome.get('model_only_prob') is not None
                )
                if ai_sum > 0:
                    total_after = ai_sum
                    # ã€é˜²å¾¡ã€‘ç¡®ä¿ total_after ä¸ä¸º None
                    total_after = total_after or 0.0
                    if total_after is None:
                        print("âš™ï¸ [SAFE] ä¿®å¤ç©ºå€¼ä¿æŠ¤: total_after (å€™é€‰äººå‹)")
                        total_after = 0.0
                    print(f"[DEBUG] å€™é€‰äººå‹å½’ä¸€åŒ–éªŒè¯ï¼šnormalization_info total_after ä¸º 0ï¼Œä» outcomes è®¡ç®—å¾—åˆ°: {(total_after or 0.0):.2f}%")
            
            # ã€ä¿®å¤ã€‘ç¡®ä¿ total_after å’Œ error ä¸ä¸º None
            if total_after is not None:
                try:
                    total_after_val = float(total_after)
                    error_val = float(error) if error is not None else 0.0
                    
                    if is_normalized:
                        if error_val <= 0.01:
                            output += f"\nâœ… *æ¦‚ç‡å½’ä¸€åŒ–å®Œæˆ* \\(æ€»å’Œ={total_after_val:.2f}%ï¼Œè¯¯å·®â‰¤{error_val:.4f}%\\)"
                        else:
                            output += f"\nâš ï¸ *å½’ä¸€åŒ–è­¦å‘Š* \\(æ€»å’Œ={total_after_val:.2f}%ï¼Œè¯¯å·®={error_val:.4f}%\\)"
                    else:
                        output += f"\nâ„¹ï¸ *æ¡ä»¶äº‹ä»¶ç‹¬ç«‹å¸‚åœº* \\(æ€»å’Œ={total_after_val:.2f}%ï¼Œæœªå½’ä¸€åŒ–\\)"
                except (TypeError, ValueError):
                    print("âš ï¸ total_after æˆ– error æ•°æ®æ ¼å¼é”™è¯¯ï¼Œè·³è¿‡æ ¼å¼åŒ–")
                    output += f"\nâ„¹ï¸ *æ¡ä»¶äº‹ä»¶ç‹¬ç«‹å¸‚åœº*ï¼ˆæœªå½’ä¸€åŒ–ï¼‰"
            else:
                output += f"\nâ„¹ï¸ *æ¡ä»¶äº‹ä»¶ç‹¬ç«‹å¸‚åœº*ï¼ˆæœªå½’ä¸€åŒ–ï¼‰"
        else:
            # å¦‚æœæ²¡æœ‰å½’ä¸€åŒ–ä¿¡æ¯ï¼Œæ‰‹åŠ¨è®¡ç®—æ€»å’Œ
            ai_total = sum(
                outcome.get('model_only_prob') or outcome.get('prediction', 0) or 0
                for outcome in sorted_outcomes
                if outcome.get('model_only_prob') is not None or outcome.get('prediction') is not None
            )
            output += f"\nğŸ“Š *AIé¢„æµ‹æ€»å’Œï¼š* {ai_total:.2f}%"
        
        # Add DeepSeek section, versions and weight source sections before normalization info
        combined_sections = ""
        if deepseek_section:
            combined_sections += deepseek_section
        if versions_section:
            combined_sections += versions_section
        if weight_source_section:
            combined_sections += weight_source_section
        
        if combined_sections:
            output = output.rstrip('\n') + combined_sections
        
        return output
    
    def format_error(self, error_message: str) -> str:
        """Format error message in Chinese."""
        error_escaped = self.safe_markdown_text(error_message)
        return f"âŒ *é”™è¯¯:* {error_escaped}"
